第一周第一节关键词：
    ☛ git与github
    ☛ 预解释（2条）
    ☛ 如何区分全局变量和私有变量
    ☛ 如何查找上级作用域，作用域链
    ☛ 堆内存与栈内存
    ☛ 引用数据类型的赋值过程（3步）
    ☛ 函数的执行过程（4步）
    ☛ 闭包
    ☛ 内存释放（3条）
    ☛ this关键字（3条）
===============================================================================
git与github
    git:用来管理代码的工具。帮我们记录每次把代码提交的时候自己的状态
    github:开源代码存放的位置（开源仓库）
    1>.准备工作
        1.安装git
        2.注册一个github账号
    2>.git工具简单命令
        1.如何克隆代码（git clone）
            1.在本地文件夹内打开右键，打开gitbash
            2.执行命令：git clone 仓库地址
        2.如何更新代码(git pull)
            进入仓库执行命令：git pull origin master
        3.如何让本地文件夹和远程仓库连接
            1.git init 先把本地文件夹初始化成一个仓库
            2.git remote add 连接名字 仓库地址(以.git结尾)
            3.git remote -v 查看有多少个连接
        4.如何把本地代码推送到新建的远程仓库
            1.在自己的用户名下新建仓库，不可以勾选read me
            2.主动建立连接之后执行以下步骤：
                a.添加和提交代码
                    git add -a  将所有代码添加到暂存区
                    git commit -m  '日志' 这一次提交为了完成什么，或者提交时把需求号写在这历史区，会生成版本号
                b.推送代码
                    git push 连接名 master
                c.输入用户名，输入密码

将项目上传到服务器：
    主机：123.57.223.74
    用户名：stu2496464248
    密码：zfpx
    访问：work.zhufengpeixun.cn/stu2496464248
▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂
1、预解释（也叫变量提声）
    概念：在当前作用域，js代码执行之前，浏览器首先会把带var和function进行提前声明或者定义
    预解释规则：
        1>.带var的，会提前声明，默认赋值为undefined
            console.log(num);//undefined  不会报错
            var num=2;
            console.log(num);//2
        2>.带function的，会提前声明+定义（赋值）
            fn();//1
            function fn(){
                console.log(1);
            }
            fn();//1
        预解释只发生在当前作用域中，开始只对window下的进行预解释，只有函数执行的时候，才会对函数中的值进行预解释
    p.s:声明和定义的区别：
        声明：var num   告诉浏览器会在全局作用域有一个num的变量了
        定义：num=value 给变量num进行赋值

2、预解释变态机制
    1>.预解释不看值。即使等号右边是一个函数也不会把这个函数名字提前声明
        console.log(fn);//fn is not defined
        var f=function fn(){
            console.log(1);
        }
    2>.预解释不理会条件。即使条件是false那么也没关系
        console.log(num);//undefined
        if(false){
            var num=2;
        }
    3>.自运行函数的函数名不进行预解释。所以自运行函数一般都是匿名函数
        console.log(fn);//报错  fn is not defined
        ;(function fn(){
            console.log(1);
        })();
    4>.return后面如果返回的是函数，那么这个返回函数的名字并不会被预解释。而return下面的代码虽然不执行，但是需要进行预解释。如果return后面是一个函数执行，那么先执行然后把执行结果return
        function fn(){
            //console.log(fx);//fx is not defined
            return function fx(){
                console.log(num);//undefined
            }
            var num=5;
        }
        var f=fn();
        f();
    5>.在预解释时，如果名字已经声明过了，不需要再重新声明，但是需要重新赋值
        如果函数和变量重名，以变量的值为准*************************************
        console.log(fn);//function fn(){console.log(2);}
        function fn(){
            console.log(1);
        }
        function fn(){
            console.log(2);
        }
        var fn=3;
        console.log(fn);//3

3、如何区分全局变量和私有变量
    在全局作用域下声明的变量是全局变量，在私有作用域中声明的变量以及函数的形参都是私有变量(==>有没有var过，是不是形参？)
    p.s:函数体外部是不能访问私有变量的
        在函数体内部是可以访问全局变量的
        任何全局变量都可以认为是window的一个属性
        赋值的时候，如果这个变量不存在，那么至少能赋值给全局变量
        取值如果查找到window还没有就报错
4、栈内存与堆内存
    栈内存：供代码执行的环境，也叫作用域（分为全局作用域和私有作用域）
    堆内存：用来存储引用数据类型的值，比如对象存储的是属性名和属性值组成的字符串，而函数存储的是代码字符串

5、引用数据类型的赋值过程
    1>.开辟一个堆内存地址
    2>.把引用数据类型中的代码当做字符串存入这个地址
    3>.最后把这个内存地址返回给引用数据类型，并且赋值。

6、函数的执行过程
    1>.提供一个供代码执行的环境==》私有作用域（栈内存）
    2>.形参赋值。如果实参是引用数据类型，那么形参和实参共用一个地址。
    3>.预解释函数体中的代码
    4>.代码逐行执行

7、如何查找上级作用域
    上一级作用域是谁，先看这个函数是在哪里定义的，然后看在定义的位置哪个函数包含着当前函数。那么这个包含它的函数就是上一级作用域。依次类推....
    p.s:上级作用域就是谁，和函数在哪执行的没有任何关系
    在私有作用域中，代码执行的时候，遇到了一个变量，我们首先需要确定它是否为私有变量，如果为私有变量，那么和外面的任何东西都没有关系。如果不是私有的，则往当前作用域的上级作用域进行查找，如果上级作用域也没有，则继续查找，一直找到全局window为止（===》作用域链），如果window还没有，那么就报错。报错后，如果没有特殊处理，代码会停止运行。

8、闭包
    概念：函数在执行的时候就会形成一个私有作用域，而这个私有作用域内的变量是不受外界干扰的。我们把这种私有作用域保护私有变量不受外界干扰的机制就叫闭包。
    如何制造闭包：有一个执行的函数
    实例：制造闭包，保护变量n不受到外界干扰：
        (function (){
            var n = 0;
            document.body.onclick = function (){
                n++;
                document.getElementsByTagName('title')[0].innerHTML = n;
            }
        })();

9、内存释放
    部分浏览器内存释放原理：
        [谷歌浏览器]
        我们开辟一个内存，可能或有一些其他的变量等占用了这个内存，谷歌浏览器都会间隔一段时间看这个内存还有没有被占用，如果发现有没有被占用的内存了，就自己帮我们回收了(内存释放)
        [火狐和IE]
        我们开个内存，当我们引用了它，就在内存中记录一个数,增加一个引用浏览器就把这个数+1，减少一个引用，浏览器就把这个数-1...当减到零的时候浏览器就把这个内存释放了;但是有些情况下(尤其是IE)记着记着就弄乱了，内存就不能释放了-->浏览器的内存泄露
    a.堆内存释放
    引用类型在定义的时候首先都会开辟一个堆内存，堆内存有一个引用的地址，如果外面有变量或者对象属性等知道了这个地址，我们就说这个内存被占用了，就不能销毁了。
    我们想要让堆内存释放/销毁，只需要把所有引用它的变量或者对象属性主动赋值为null即可，如果当前的堆内存没有任何东西被占用了，那么浏览器会在空闲的时候把它销毁。
    b.栈内存释放
    全局作用域：只有当页面关闭的时候，才会销毁
    私有作用域：只有当函数执行时才会产生私有作用域
    一般情况下，函数执行会形成一个新的私有的作用域，当私有作用域当中的代码执行完成后，当前作用域都会主动进行释放和销毁，但是还是存在特殊情况，当前私有作用域中的部分内存被作用域以外的东西占用了，那么当前这个作用域就不能销毁了
    1>.函数执行返回了一个引用数据类型的值，并且在函数的外面被一个变量或对象的属性所占用，这种情况下，一般形成的私有作用域都不会被销毁
        function fn() {
            var num=100;
            return function () {
            }
        }
        var f=fn();//fn执行结果是引用数据类型，被变量f占用，所以形成的私有作用域不能被销毁
        document.body.xxx=fn();//fn执行结果是引用数据类型，被body对象的xxx属性占用，所以形成的私有作用域也不能被销毁
    2>.DOM对象的事件属性占用函数执行之后的返回的引用数据类型值，那么也符合作用域不被释放的情况(第一种情况的特殊情况)
        div1.onclick = (function (){
            var num=0;//num=1 num=2 num=3 num=4....  因为这个作用域不被释放，所以num的值也被保留下来了
            return function (){
                num++;
                console.log(num);//1 2 3 4 ....
            }
        })();
        方法二（推荐）：
        ;(function (num){
            div1.onclick = function (){//也是作用域不被释放的情况（div1.onclick可以理解为全局下对象的属性）
                num++;
                console.log(num);
            }
        })(0);
    3>.下述情况属于不立即销毁：函数执行返回的函数立刻执行，所以暂时不销毁，但是当返回的值执行完成后，浏览器会在空闲的时候把它销毁
        function fn() {
            var num=100;
            return function () {
            }
        }
        fn()();//首先执行一个fn，返回一个小函数对应的内存地址，然后紧接着让返回的小函数再次执行
    内存释放综合实例：*****************************
        function fn(m){
            return function(n){
                console.log(n+m++);
            }
        }
        var f1=fn(10);//fn第一次执行，形成一个私有作用域
        f1(12);//22  作用域不释放
        f1(13);//24  作用域不释放
        var f2=fn(13);//fn第二次执行，形成一个新的私有作用域
        f2(12);//25  作用域不释放
        f2(13);//27  作用域不释放
        fn(12)(13);//25   fn第三次执行，形成一个新的私有作用域，作用域暂时不释放，执行完成后释放
        fn(12)(13);//25   fn第四次执行，形成一个新的私有作用域，作用域暂时不释放，执行完成后释放
    注：函数每次执行都会形成一个新的私有作用域，而这些作用域之间没有任何关系。

10、this关键字
    js中的this代表的是当前行为执行的主体
    this是谁和函数在哪定义的和在哪执行的都没有任何关系，如何区分this?
    1>.函数执行，首先看函数名之前是否有点，有的话，'.'前面是谁，this就是谁，没有的话，this就是window
        var obj={
            fn:function(){
                console.log(this);//this -->obj
            }
        };
        obj.fn();
    2>.自执行函数中的this永远是window
        ;(function(){
            console.log(this);//this -->window
        })();
    3>.给元素的某一个事件绑定方法，当事件触发的时候，执行对应的方法，方法中的this是当前的元素
        var oDiv = document.getElementById('div');
        [DOM零级事件绑定]
          oDiv.onclick=function(){
             //this->oDiv
          };
        [DOM二级事件绑定]
          oDiv.addEventListener("click",function(){
             //this->oDiv
          },false);
        //在IE6~8下使用attachEvent
          oDiv.attachEvent("click",function(){
               //this->window
          });
    4>.在构造函数模式中,我们的this.xxx=xxx中的this是当前的类的一个实例
        function Fn(){
            this.x=100;//this->f x是给当前实例f增加的私有的属性
        }
        Fn.prototype.getX=function(){
            console.log(this.x);
        };
        var f=new Fn;
        f.getX();//getX中的this->f
        f.__proto__.getX();//getX中的this->Fn.prototype
    5>.call和apply还有bind都可以强制改变this
        一般情况下,我们执行call方法第一个传递的参数值是谁,那么fn中的this就是谁
        [在非严格模式下]
        第一个参数没有传递值、传递的是null/undefined，fn中的this都是window
        [严格模式下]
        第一个参数传递的是谁this就是谁,传递null/undefined，fn中的this都是对应的null/undefined,不传递值默认也是undefined
    6>.定时器中的this指window
    7>.回调函数中的this指window


