第二周第二节关键词：
    ☛ 正则的作用
    ☛ 正则元字符
    ☛ 正则的验证和捕获
    ☛ 正则实战
===============================================================================
1、正则
   验证：用来验证字符串是否符合这个正则所制定的规则。
   捕获：把符合规则的部分获取，捕获到的结果
2、正则的创建
   字面量创建：var reg=/a/;
   实例创建：var reg=new RegExp('a');
   字面量方式和实例创建方式的区别：
        使用字面量方式不可以把变量添加到正则中
        实例创建方式：第一个参数是字符串（就是字面量的方式放在两个斜杠中的那些字符）==>第二个参数就是修饰符(img)，也是一个字符串
        p.s:只要正则中需要引入变量，那么只能使用实例的创建方式
            如果在实例方式创建正则使用\d等特殊元字符，还需要转义一次。也要在前面添加一个"\"*************
3、正则的元字符
    1>.常用元字符
        \d    0-9之间的数字
        \D    除了\d
        \w    数字，字母下划线 0-9 a-z A-Z _
        \W    除了\w
        \s    空(空字符串，空格，多个空格)
        \b    边界。不一定是字符串的开头或者结尾，空格也是边界，百分号%两边也是边界.....
        \n    换行
         .    任意字符，除了\n和空字符串
        \.    把这个.从任意字符转为.本身，其中\是转义的意思
        \     转义，一般用来转特殊意思的元字符
        ^     以什么开始
        $     以什么结束
            ps:^$组合在一起，那么不仅仅约束开头和结尾，然后还约束字符串的长度，从头到尾全部匹配
                \b ^ $ 这几个只是约束限定的条件，不占位
                var reg=/^\d\d$/;
                var str="92afdsafds94";
                var res=reg.test(str);
                console.log(res);//false
    2>.量词
        ?   出现0-1次   --》可以出现可以不出现
        *   出现0-多次  --》可以不出现，也可以出现无数次
        +   出现1-多次   --》至少出现1次
       {n}   出现n次
       {n,}   出现n-多次
       {n,m}   出现n-m次
    3>.或者关系
        |   使用或者关系的时候，为了保证严禁，我们不妨加一个小括号来改变优先级 var reg=/^(15|16)$/;
        [xyz]  x或者y或者z中的一个
        ^[xyz]  除了x或者y或者z中的任意一个
           var reg=/[^xyz]/;
           var str="abdsafdsxfds";
           console.log(reg.test(str));//-->true
           var str="x";
           console.log(reg.test(str));//-->false
    4>.[]的用法
        [.]    代表.本身
        [\d]   仍然代表0-9中间的数字
        [\s]   代表空格或制表符
        [a-z]  代表a-z中的一个
        \w  相当于  [0-9a-zA-Z_]
    5>.正则的修饰符：
        i    忽略大小写
        m    多行匹配
        g    全局匹配
    6>.分组    ()
        在正则表达式中，()不仅仅有改变优先级的作用，还有分组的作用
        只要存在了分组，使用exec方法的捕获结果也会发生改变，第一项仍然是最大的正则捕获到的内容。从第二项开始，依次是正则中分组所对应匹配到的内容
        举例：
            var reg=/\d{17}(\d|x)/i
            var reg=/(\d{2})(\d{2})(\d{2})(\d{4})(\d{2})(\d{2})(\d{3})(\d|x)/;
            var str="622301199110043521";
            var res=reg.exec(str);
            console.log(res);//["622301199110043521", "62", "23", "01", "1991", "10", "04", "1", index: 0, input: "622301199110043521"]
    7>.?:
        这个分组只匹配不捕获，其实也就是取消破坏分组，只是用小括号来改变优先级，不是来分组的
        用法：(?:\d|x)  ?:放在分组的开头
    8>.分组的引用
        只要正则中出现了分组，那么就可以使用\n来引用这个分组所匹配到的内容
        /(\w)\1/  \1跟第一个分组完全相同
4、正则的验证
    手机号  var reg=/^1\d{10}$/;
    非空验证
        var reg=/^\s*$/;
        console.log(reg.test(""));//true
        console.log(reg.test(" a"));//false
        匹配结果取反，就是非空验证
    有效数字验证
        var reg=/^[+-]?\d+(\.\d+)?$/;
        console.log(reg.test("1.a"));//false
        console.log(reg.test("1"));//true
    邮箱验证
        var reg=/^\w{1,26}@[0-9a-zA-Z]{1,20}(\.[a-z]{2,3}){1,2}$/;
        console.log(reg.test("asd@sd.com"));
4、正则的捕获
    1>.exec
        exec的捕获结果：是一个数组：["捕获到的内容","捕获开始的索引位置","捕获的那个整个字符串"]
        reg.lastIndex属性是负责下次正则从哪个位置开始匹配或者捕获
        如果没有全文g那么lastIndex属性的值一直都是0，每次都从开头开始匹配
        如果捕获当次没有捕获到，结果返回null
    2>.match
       返回值仍然是一个数组
       在正则中包含g，一次能够把所有字符串中符合要求的全部捕获到
       在正则中不包含g，和exec完全相同，也是每次从开始位置捕获
       ps:match方法在存在g的时候，虽然一次性能够把所有的符合要求的全部捕获到，然而那个记录捕获索引位置的index属性就不存在了
       如何用exec模拟match方法
        var reg=/\d+/g;//如果没有g会死循环
        var str="zhufeng2015zhufeng2016";
        var res=reg.exec(str);
        console.log(res);
        var ary=[];
        while(res){//reg.exec(str)为null时，停止循环
            ary.push(res[0]);
            res=reg.exec(str);
        }
        console.log(ary);//["2015", "2016"]
        lastIndex的属性是支持赋值的，前提条件是有g    test,exec,match都支持修改
        lastIndex在存在g的情况下，每次执行exec方法之后都会被修改一次。
    3>.replace
        复习：split：参数可以是一个正则
                var str="a b c";
                console.log(str.split(/ /));//["a", "b", "c"]
                var str="a@b&c";
                console.log(str.split(/[@&]/));//["a", "b", "c"]
                var str="fds12";
                console.log(str==str.replace('fd','abc'));//==>false  返回的是一个替换好的新的字符串，不是把原来的替换了
        replace用法总结(正则用法)
            第一个参数是正则，第二个参数是函数
            匿名函数执行多少次取决于正则成功匹配到的次数
            正则成功匹配到的内容用函数的返回值来替换
            函数的arguments：[正则本次匹配的内容，分组1，....分组n,index,input]
            ps:replace的返回值和arguments做好区分
        举例：
            var reg=/\d+/g;
            var res=str.replace(reg,function(item,index,str){
                //console.log(item,index,str);//2015 7 zhufeng2015zhufeng2016
                //console.log(arguments);//["2015", 7, "zhufeng2015zhufeng2016"]  ["2016", 18, "zhufeng2015zhufeng2016"]
                //return "珠峰";//zhufeng珠峰zhufeng珠峰
                return index;//zhufeng7zhufeng18
            });
            console.log(res);

RegExp.$1保存着最后一个正则实例捕获到的分组内容 不兼容  最大$9

6、正则的特性
    懒惰：每次尽可能少的匹配
    破坏懒惰：加g
    贪婪：每次尽可能多的匹配
    破坏贪婪：量词后面加?
7、?的用法
    1> ?本身
    2> \d?  量词
    3> (?:\d+) 匹配不捕获
    4>  ?=  正向预查
    5>  ?!  负向预查
8、正向预查与负向预查
    ?=  只是一个肯定的限定条件，并不占位  (?=x|y)    必须是x或者y
    ?!  只是一个否定的限定条件，并不占位  (?!x|y)    不能是x或者y
